#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass article
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 2cm
\topmargin 2cm
\rightmargin 2cm
\bottommargin 2cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Part*
PROTOCOLLO HTTP
\end_layout

\begin_layout Standard
HTTP è un protocollo di trasporto di contenuti generici alla base del web
 e di tutte le applicazioni costruite su tale piattaforma.
 Si appoggia ad un protocollo di trasporto esistente che nella maggior parte
 dei casi è il TCP.
\begin_inset Newline newline
\end_inset

Gestisce uno scambio elementare: il client invia una richiesta e il server
 produce una risposta: ognuna di queste richieste sono indipendenti così
 come è indipendente l'utilizzo di tale protocollo rispetto al contenuto.
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

Sia la richiesta che la risposta sono formate da un'intestazione e da un
 corpo (il cui contenuto è definito nell'intestazione).
 Tutte le transazioni HTTP riguardano operazioni su risorse informative
 specificate attraverso una URL, una stringa univoca costituita da più sottopart
i (schema://hostname[:port]/path):
\end_layout

\begin_layout Itemize
schema indica il protocollo tramite cui agire
\end_layout

\begin_layout Itemize
hostname[:port] è l'indirizzo in cui il server si trova in attesa di connessioni
\end_layout

\begin_layout Itemize
path indica la posizione relativa dell'oggetto all'interno del server
\end_layout

\begin_layout Standard
La prima riga di una richiesta contiene:
\end_layout

\begin_layout Itemize
L'azione da svolgere: GET (richiede l'invio della risorsa indicata dalla
 URL), POST (invia un insieme di informazioni alla risorsa, tipicamente
 un programma, indicata dalla URL e richiede il documento risultante), PUT
 (richiede l'aggiornamento di una risorsa sul server identificata dalla
 URL), PATCH (richiede l'aggiornamento parziale di una risorsa), DELETE
 (richiede la distruzione della risorsa indicata)
\end_layout

\begin_layout Itemize
La URL relativa dell'oggetto su cui operare
\end_layout

\begin_layout Itemize
La versione del protocollo usata dal client
\end_layout

\begin_layout Standard
Un'azione è idempotente se l'effetto sul server di più richieste identiche
 è lo stesso di quello di una sola richiesta ed è sicura se non genera cambiamen
ti nello stato interno del server.
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

Le risposte rappresentano il risultato della richiesta tramite un codice
 ed una descrizione.
 Il sostanziale mutare nel tempo dei tipici contenuti trasferiti ha reso
 il meccanisco di trasporto poco efficiente (la latenza è un fattore critico):
 con HTTP/2, su una singola connessione TCP vengono multiplate più transazioni,
 ognuna delle quali è incapsulata in un pacchetto binario che la identifica.
 Più richieste possono essere emesse in cascata e le risposte non devono
 seguire l'ordine delle richieste: il pacchetto permette di ricostruire
 a quale richiesta faceva riferimento.
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Part*
APPLICAZIONI HTTP
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Lo standard prevede quattro possibili ruoli per le applicazioni che utilizzano
 HTTP:
\end_layout

\begin_layout Itemize
User-agent: applicazione che origina le richieste HTTP
\end_layout

\begin_layout Itemize
(Origin) Server: applicazione che ospita le risorse trasferibili.
 Accetta quindi richieste e genera le corrispondenti risorse
\end_layout

\begin_layout Itemize
Proxy: intermediario scelto dallo user-agent per inoltrare le richieste
 al server.
 Può filtrare le richieste, tradurre indirizzi e servirsi di una memoria
 temporanea per aumentare le prestazioni
\end_layout

\begin_layout Itemize
Gateway: intermediario trasparente allo user-agent che inoltra le richieste
 all'origin effettivo
\end_layout

\begin_layout Standard
Esistono due tipologie di proxy: quelli trasparenti dove la risposta viene
 inoltrata al client senza modifiche (è comunque capace di usare una cache
 e possiede un sistema di filtraggio) e quelli non trasparenti, che inoltrano
 tutte le richieste ma hanno la possibilità di modificare le risposte.
\begin_inset Newline newline
\end_inset

Basic Authentication: ad ogni gruppo di risorse tra loro correlate è associato
 un contesto di sicurezza chiamato realm.
 Per ogni realm è definita una lista di utenti autorizzati, con le relative
 password: quando il server manda una 401-Unauthorized, specifica il realm-name
 ed è compito del client formulare una nuova richiesta (dopo aver chiesto
 all'utente user e password) con le informazioni necessarie codificate in
 base64 (che però è una codifica reversibile quindi OCCHIO).
\begin_inset Newline newline
\end_inset

Digest authentication: invece di inviare la password, è possibile inviare
 un dato derivato in modo irreversibile dalla password.
 Client e Server eseguono la derivazione in modo indipendente, cosicchè
 se le due coincidono, il client ha dimostrato di conoscere la password
 senza inviarla in chiaro; occorre difendersi da tentativi di proporre la
 stessa derivazione da parte di un'eventuale attaccante.
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

Poichè HTTP tratta tutte le richieste come tra loro indipendenti, occorre
 introdurre a livello applicativo un meccanismo per supportare questa modalità
 di lavoro.
 Nasce così il concetto di sessione: un insieme di richieste, proveniente
 dallo stessso browser e dirette allo stesso server, confinate in un dato
 lasso di tempo, volte ad interagire con risorse tra loro correlate.
 E' possibile sia creare sessioni nominali che sessioni anonime.
\begin_inset Newline newline
\end_inset

Il web server associa una richiesta proveniente da un dato client ad un
 identificatore univoco (SessionID): tale identificatore viene comunicato
 al client per le successive richieste.
 Dopo un certo periodo di inattività dell'utente, la sessione scade e ne
 viene perso lo stato; l'ID può essere sia generato sequenzialmente a partire
 da un valore dato oppure essere generato casualmente.
 In ogni caso, tale ID viene trasferito al client in diversi modi: passaggio
 esplicito nel contenuto del documento, utilizzando i cookies, riscrivendo
 i link o coordinando le sessioni lato client.
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Part*
ANNOTAZIONI JAVA
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Le annotazioni permettono di inserire dei metadati che descrivono le caratterist
iche di una classe.
 Esse possono essere usate per informare il compilatore (rilevare errori
 o evitare i warning), generare informazioni durante la compilazione di
 un pacchetto software o condizionare l'esecuzione di un programma (è possibile
 esaminare una classe durante l'esecuzione per verificare la presenza di
 annotazioni e comportarsi di conseguenza).
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public @interface RequestForEnhancement{
\end_layout

\begin_layout Plain Layout

	int id();
\end_layout

\begin_layout Plain Layout

	String synopsis();
\end_layout

\begin_layout Plain Layout

	String date();
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

Il simbolo @ precede la keyword interface e i metodi definiscono le proprietà
 dell'annotazione.
 Una volta definito il tipo di annotazione, questo può essere usato per
 annotare delle dichiarazioni.
 Le dichiarazioni dei metodi non devono avere parametri e non devono prevedere
 clausole di tipo throws, infine i tipi di ritorno devono essere tipi primitivi,
 String, Class, enum o array di questi.
\begin_inset Newline newline
\end_inset

Le meta-annotazioni servono per annotare le dichiarazioni delle annotazioni
 (annotazioni di annotazioni), esempi sono: @Target, @Retention, @Documented,
 @Inherited.
 Usando JPA è possibile anche configurare il comportamento delle proprie
 entità usando le annotazioni (come @Entity, @OneToOne, @PrimaryKey o @Column).
\begin_inset Newline newline
\end_inset

Con la nascita delle annotazioni è nato anche il progetto Lombok, che è
 un'estensione del compilatore in grado di convertire annotazioni presenti
 nelle classi in codice sorgente Java e quindi permette di trasformare un
 oggetto annotato con @Data aggiungendo getter/setter/costruttore in automatico.
 Le classi annotate con @Data, inoltre, hanno tutti i campi non esplicitamente
 final mutabili, mentre annotando con @Value tutti i campi vengono resi
 privati e immutabili.
 In conclusione, le annotazioni Java rappresentano una standardizzazione
 dell'approccio di annotazione del codice: non riguardano direttamente la
 semantica del programma ma possono semplificare notevolmente la quantità
 di codice che è necessario scrivere a mano senza compromettere le funzionalità.
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Part*
MAVEN
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Maven è uno strumento a supporto del processo di creazione e manutenzione
 del software.
 E' una versione evoluta di make, con supporto all'importazione delle dipendenze
, alla creazione di moduli differenti ed all'utilizzo di plugin per la compilazi
one e la messa in campo.
 Supporta le diverse fasi del ciclo di vita di un prodotto software, e le
 singole applicazioni sono eseguite da plugin.
\begin_inset Newline newline
\end_inset

E' necessario un file POM (Project Object Model), un file XML che descrive
 la struttura di un progetto; il progetto e ciascun artefatto da esso utilizzato
 vengono identificati in modo univoco tramite la notazione GAV(groupId :
 artifactId : version):
\end_layout

\begin_layout Itemize
groupId: identificatore arbitrario del progetto di solito derivato dal package
 Java
\end_layout

\begin_layout Itemize
artifactId: nome arbitrario del progetto
\end_layout

\begin_layout Itemize
version: versione del progetto
\end_layout

\begin_layout Standard
Un file POM può ereditare la propria configurazione e in tal modo facilita
 la gestione di progetti composti da più sotto-progetti.
\begin_inset Newline newline
\end_inset

Un progetto Maven può essere costituito da un insieme di moduli ognuno dei
 quali è contenuto in una sotto-cartella ed ha un proprio file POM; nella
 cartella del progetto è presente il file POM complessivo: target è la cartella
 di lavoro di default e src contiene tutti i file sorgente.
 
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

Per default, la creazione di un artefatto passa attraverso le seguenti fasi
 principali: generazione dei sorgenti e delle risorse (generate*, qui vengono
 eseguiti eventuali pre-processor del codice sorgente), compilazione (compile),
 esecuzione dei test sui moduli (test), impacchettamento (package), test
 di integrazione (integration-testing), installazione (install) e messa
 in campo (depoly).
 Separatamente viene considerata la fase di pulizia generale (clean, che
 elimina tutti i file intermedi e di uscita).
\begin_inset Newline newline
\end_inset

Nella maggior parte dei casi, un progetto reale si basa su un insieme di
 altri progetti/librerie.
 Per ogni elemento di tipo <dependency> occorre indicare GroupId, ArtifactId,
 Version, Scope; quest'ultimo <scope> definisce in quale fase del ciclo
 di vita del progetto la dipendenza dovrà essere considerata: compile (indica
 che la risorsa è necessaria per l'intero ciclo di vita), provided (indica
 che la risorsa è necessaria durante la fase di compilazione, ma non dovrà
 essere inclusa nell'artefatto finale in quanto messa a disposizione dall'ambien
te di esecuzione), runtime (indica una risorsa da includere solo in fase
 di esecuzione) e test (indica una risorsa necessaria esclusivamente in
 fase di test).
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

Per ogni risorsa indicata come dipendenza, il corrispondete modulo software
 viene scaricato dal repository ed archiviato nella cache locale (viene
 scaricato inoltre anche il file POM corrispondente).
 Se, dall'analisi del POM, un modulo scaricato dichiaradi dipendere da altri
 moduli, questi vengono scaricati transitivamente (ma solo se sono 
\begin_inset Quotes eld
\end_inset

compile
\begin_inset Quotes erd
\end_inset

 e 
\begin_inset Quotes eld
\end_inset

runtime
\begin_inset Quotes erd
\end_inset

).
\begin_inset Newline newline
\end_inset

Tutte le operazioni svolte da Maven avvengono grazie all'attivazione di
 appositi plugin, ossia classi Java che estendono una classe astratta e
 implementano il metodo void execute(); un'apposita sezione del file POM
 (<build>) elenca l'insieme di plugin che saranno utilizzati nella gestione
 del progetto.
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Part*
APPLICAZIONI JAVAEE
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Le applicazione web dinamiche implementano una data logica lato server fornendo
 un'interfaccia utente basata su pagine html e contenuti multimediali: il
 livello UI viene eseguito sul client e mostra l'interfaccia utente, il
 livello controllo viene eseguito sul server e si occupa di implementare
 la logica e il livello dati viene eseguito su una base dati e si occupa
 di memorizzare i dati applicativi.Contrariamente alle applicazioni stand
 alone, quelle web sono eseguite in modo reattivo (tutte le volte che ricevono
 una richiesta producono una risposta specifica per la sessione in corso):
 solitamente, l'applicazione reagisce alla prima richiesta mostrando una
 
\begin_inset Quotes eld
\end_inset

home page
\begin_inset Quotes erd
\end_inset

.
 Ciascuna richiesta può contenere parametri aggiuntivi (tramite form ecc..)
 e il livello di controllo deve: verificare la validità dei parametri ricevuti,
 memorizzare temporaneamente i parametri per poterli utilizzare e generare
 una risposta appropriata, permettendo all'utente di svolegere il proprio
 compito.
 La pagina inviata può poi essere personalizzata in base alle interazioni
 precedenti.
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

Nella navigazione pagina per pagina, a fronte di ogni richiesta viene generata
 una risposta che contiene una pagina HTML completa, mentre in quella progressiv
a a pagina singola solo la prima richiesta contiene la struttura della pagina,
 e le richieste successive sono effettuate con il paradigma AJAX e prevedono
 il trasferimento solo del frammento di struttura che deve essere modificato
 o di una descrizione sintetica dello stesso.
\begin_inset Newline newline
\end_inset

La navigazione a pagina singola è basata sull'utilizzo di codice JavaScript
 lato client per richiedere il frammento da aggiornare e si utilizzano le
 funzioni per la manipolazione del DOM per inserirle nella pagina; l'uso
 di librerie quali Vue, React o Angular semplifica la gestione del processo.
 I limiti di tale navigazione si incontrano quando ci si interfaccia con
 i motori di ricerca, con il tasto 
\begin_inset Quotes eld
\end_inset

indietro
\begin_inset Quotes erd
\end_inset

 dei browser e per i tempi di caricamento.
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

Le applicazioni JavaEE sono un insieme modulare di classi Java, messe in
 campo all'interno di un programma contenitore che ne gestisce il ciclo
 di vita e l'esecuzione: esse sono costituite da un insieme di componenti
 responsabili di gestire l'elaborazione di richieste HTTP e costruire le
 corrispondenti risposte, delegando in parte o in toto l'implementazione
 della logica applicativa ad uno strato di servizio che, a sua volta, può
 appoggiarsi ad uno strato di memorizzazione persistente.
 Esse sono indipendenti dallo specifico contenitore, ossia applicazioni
 in esecuzione all'interno di un calcolatore server.
 Monitorano le connessioni, applicano ad ogni richiesta un insieme di funzioni
 base, determinano l'applicazione cui è destinata la richiesta e la classe
 al suo interno responsabile di elaborarla, instanziandola se necessario
 e offrono un insieme di servizi standardizzati ai singoli componenti, semplific
andone l'implementazione.
 Utilizzano un template standard per descrivere le applicazioni web ed hanno
 un file XML di configurazione da cui il contenitore deduce tutti i dettagli
 applicativi (politiche di gestione, parametri di configurazione, corrispondenza
 fra URL e nomi delle classi ad esempio).
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

Le applicazioni JavaEE sono normalmente distribuite sotto forma di file
 
\begin_inset Quotes eld
\end_inset

.war
\begin_inset Quotes erd
\end_inset

, al cui interno sono presenti sia i contenuti che la configurazione dell'applic
azione e il cui nome rappresenta di default la URL di base in cui verrà
 pubblicata.
 Ci sono due sotto-cartelle obbligatorie (META-INF/MANIFEST.MF e WEB-INF/web.xml)
 e per installarla basta semplicemente copiare il file .war nell'apposita
 cartella del contenitore.
 Ci sono poi le componenti elementari di un'applicazione JavaEE (Servlet,
 filtri, Listener, pagine JSP).
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Subsection*
SERVLET API
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Un Servlet è una classe Java responsabile di gestire le richieste ricevute
 da un contenitore, modellando il paradigma richiesta/elaborazione/risposta
 tipico delle applicazioni lato server.
 Il contenitore ne gestisce completamente il ciclo di vita.
 Le sue API sono un insieme di interfacce e classi che definiscono, a basso
 livello, l'interazione tra codice applicativo lato server e contenitore.
 javax.servlet contiene le classi e le interfacce che definiscono il comportament
o generico di un servlet, javax.servlet.http contiene le classi e le interfacce
 che modellano il comportamento di richieste/risposte trasportate attraverso
 il protocollo HTTP.
 ServletRequest rappresenta la richiesta del client e ServletResponse rappresent
a la risposta del servlet al client (estese da HTTPServletRequest e HTTPServletR
esponse).
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

Il contenitore crea un'unica istanza del servlet e ne invoca il metodo init(),
 e finchè esso non ritorna il contenitore non invoca nessun altro metodo.
 Ad ogni richiesta, il contenitore invoca il metodo service() utilizzando
 un thread differente e infine, a proprio piacimento, il contenitore decide
 di invocare il metodo destroy() per rimuovere il servlet.
\begin_inset Newline newline
\end_inset

L'annotazione WebServlet permette di indicare la configurazione: il valore
 di default indica l'elenco di URL che vengono gestite dall'istanza del
 servlet, urlPatterns è equivalente al valore di default, initParams indica
 eventuali parametri di inizializzazione, loadOnStartup indica la politica
 di instanza, asyncSupported indica se la richiesta può essere gestita in
 modalità asincrona.
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

Metodi di HTTPServletRequest: getParameter(String name), ServletInputStream
 getInputStream(), BufferedReader getReader(), String getMethod(), Enumeration
 getParameterNames(), String getHeader(String headerName), void setAttribute(Str
ing name, Object value), Object getAttribute(String name)
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

Metodi di HTTPServletResponse: void setContentType(String contentType),
 void setStatusCode(int statusCode), void addCookie(Cookie c), void addHeader(St
ring name, String value).
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

Metodi di HTTPSession: void setAttribute(String name, Object value), Object
 getAttribute(String name), void removeAttribute(String name), String getId(),
 boolean isNew(), void invalidate()
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

Il ServletContext è un'interfaccia che definisce le interazioni tra servlet
 e suo contenitore.
 Nel caso di contenitori basati su una singola virtual machine, ogni applicazion
e web ha un unico contesto, mentre nel caso di più VM ci sono tante istanze
 di questa interfaccia quante sono le macchine virtuali attive.
\begin_inset Newline newline
\end_inset

In ogni caso, permette di creare/aggiungere/rimuovere servlet/filtri/listener
 al contenitore ed offre un meccanismo per risalire al tipo di contenuto
 di un file presente nel file system locale; inoltre, è in grado di fornire
 informazioni sul contenitore, sulle API supportate e sulle politiche in
 essere per la gestione dell'applicazione.
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

Quali sono i vantaggi di un Servlet? Di sicuro sono veloci, efficienti,
 scalabili, flessibili e persistenti; in più, il contenitore garantisce
 la separazione fisica tra applicazioni.
 Il problema è che è complicato modificare il codice HTML di risposta, la
 presentazione e la logica sono fortemente accoppiate e l'architettura rischia
 di diventare complessa se si prendono in considerazione le caratteristiche
 più avanzate.
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Subsection*
FILTRI
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Un filtro è un componente java che trasforma le richieste inviate ad un
 servlet o le risposte da esso generate.
 Ciascun filtro riceve le richieste destinate ad un (o un insieme di) URL
 e decide, in base alla propria logica, se inoltrare la richiesta al destinatari
o, modificare uno o più parametri o reindirizzare la richiesta verso un
 indirizzo differente.
 Lo stesso funzionamento vale anche per la risposta, e ci possono essere
 più filtri collegati in cascata, il tutto gestito dal file web.xml.
\begin_inset Newline newline
\end_inset

Come nel caso dei Servlet, anche per i filtri è possibile indicare il set
 di URL su cui devono essere applicati in due modi alternativi: tramite
 l'annotazione @WebFilter o inserendo delle sezioni nel file web.xml.
 Parametri:
\end_layout

\begin_layout Itemize
urlPatterns – indica la lista delle espressioni regolari che descrivono
 l'insieme delle URL su cui il filtro si applica
\end_layout

\begin_layout Itemize
servletNames – indica l'insieme dei servlet su cui deve essere applicato
 il filtro
\end_layout

\begin_layout Itemize
initParams – i parametri di configurazione del filtro
\end_layout

\begin_layout Itemize
filterName – il nome simbolico associato al filtro
\end_layout

\begin_layout Itemize
dispatcherType – indica a quale fase della gestione della richiesta debba
 essere applicato il filtro
\end_layout

\begin_layout Itemize
asynchSupported – indica se il filtro può operare in modalità asincrona
\end_layout

\begin_layout Standard
Ci sono due sezioni nel file web.xml: 
\begin_inset Quotes eld
\end_inset

filter
\begin_inset Quotes erd
\end_inset

 descrive un filtro mentre 
\begin_inset Quotes eld
\end_inset

filter-mapping
\begin_inset Quotes erd
\end_inset

 esprime la corrispondenza tra URL e filtri da utilizzare.
 Nel caso in cui ad una data URL corrispondano due o più filtri, questi
 sono applicati nell'ordine in cui le rispettive sezioni filter-mapping
 compaiono nel file web.xml
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Subsection*
JSP - JAVA SERVER PAGES
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Documenti di testo che descrivono come elaborare una richiesta per produrre
 una risposta in base ai parametri ricevuti.
 JSP è un modello di programmazione basata sul linguaggio Java e usato per
 creare dinamicamente contenuti web.
 Le pagine JSP contengono testo, frammenti di codice e direttive per l'ambiente
 di esecuzione e vengono create e gestite nel contenitore.
 Esse generano contenuto dinamico che viene visualizzato in un browser generico
 (nonostante il client non veda mai la pagina JSP iniziale, ma solo i risultati
 della sua esecuzione) grazie ai frammenti di codice Java, per cui semplici
 oggetti (JavaBeans) possono essere utilizzati per incapsulare data storage
 o altre operazioni di tipo business.
\begin_inset Newline newline
\end_inset

Che vantaggi porta l'utilizzo di JSP? Si può modificare il contenuto delle
 pagine web senza cambiare il codice HTML di layout e vi è quindi una separazion
e tra i contenuti dinamici e quelli statici; inoltre, i JavaBeans e i tag
 personalizzati permettono il riutilizzo di codice e l'utilizzo di semantiche
 dichiarative.
 L'unico problema è che il programmatore deve occuparsi di progettare ed
 implementare una macchina a stati opportuna per gestire l'interazione con
 l'utente.
\end_layout

\begin_layout Enumerate
Il contenitore riceve la richiesta della pagina JSP (direttamente o tramite
 server HTTP)
\end_layout

\begin_layout Enumerate
Il file viene identificato e trasformato in classi sorgenti Java (tramite
 pageCompiler)
\end_layout

\begin_layout Enumerate
Il compilatore Java compila la classe prodotta
\end_layout

\begin_layout Enumerate
La richiesta ricevuta e i relativi parametri vengono inviati all'oggetto
 generato (servlet), che la elabora
\end_layout

\begin_layout Enumerate
Il risultato viene inviato al client
\end_layout

\begin_layout Standard
Nel caso in cui venissero ricevute più richieste per la stessa risorsa,
 vengono omessi i passi 2 e 3
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

Le pagine JSP sono composte da tag standard HTML e tag JSP:
\end_layout

\begin_layout Itemize
Commenti 
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

<%-- comments..
 --%>
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Direttive 
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

<%@ page import=
\begin_inset Quotes erd
\end_inset

java.util.*
\begin_inset Quotes erd
\end_inset

 %>
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Scriptlet 
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

<% if( session.isNew() ){ <p> Welcome </p> } %> 
\end_layout

\begin_layout Plain Layout

<%! some declaration %> 
\end_layout

\begin_layout Plain Layout

<%= expression %>
\end_layout

\end_inset

Permettono al programmatore di accedere e memorizzare informazioni relative
 all'elaborazione corrente (request = HttpServletRequest, response = HttpServlet
Response, out = JspWriter)
\end_layout

\begin_layout Standard
Per redirigere la pagina JSP ad una determinata URL, per separare l'elaborazione
 della richiesta dalla visualizzazione della risposta: <jsp:forward page=
\begin_inset Quotes erd
\end_inset

URL
\begin_inset Quotes erd
\end_inset

 />
\begin_inset Newline newline
\end_inset

Inserimento di una pagina identificata da una URL durante l'esecuzione:
 <jsp:include page=
\begin_inset Quotes erd
\end_inset

URL
\begin_inset Quotes erd
\end_inset

 flush=
\begin_inset Quotes erd
\end_inset

true
\begin_inset Quotes erd
\end_inset

 />
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

La pagina JSP viene trasformata in classe java
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public void _jspService(
\end_layout

\begin_layout Plain Layout

	HttpServletRequest req, 
\end_layout

\begin_layout Plain Layout

	HttpServletResponse res) throws IOException, ServletException;
\end_layout

\end_inset

Il codice di _jspService è composto da: inizializzazione e gestione degli
 errori e codice contenuto nello scriptlet e dalle richieste di stampa di
 testo sull'oggetto 
\begin_inset Quotes eld
\end_inset

out
\begin_inset Quotes erd
\end_inset

 incapsulate tra due scriptlet.
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Subsection*
LISTENER
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
L'insieme dei componenti ospitati all'interno di un contenitore JavaEE è
 completamente gestito da questo: ne governa il ciclo di vita, ne definisce
 le politiche di attivazione, controlla l'uso delle risorse e della concorrenza.
 Il contenitore offre un insieme di meccanismi volti a permettere ad un'applicaz
ione di reagire opportunamente ai cambiamenti degli stati dei singoli componenti.
 I listener permettono inizializzazione e distruzione del WebContext, modificare
 attributi del WebContext, creazione, modifica e distruzione di sessioni,
 ricezione e modifica dei parametri di una richiesta da parte del contenitore.
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

Si dichiara un ascoltatore degli eventi legati ad un contesto web attraverso
 l'annotazione @WebListener: nel momento in cui viene deployata l'applicazione,
 tutte le sue classi sono scandagliate alla ricerca di eventuali ascoltatori
 (creando un'istanza di tali classi e associando la tipo di evento che essi
 dichiarano di ascoltare) e quando si verifica un evento del tipo richiesto
 si invoca il metodo opportuno (nel contesto del thread in cui si è verificato
 l'evento.
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Part*
IL PARADIGMA MVC
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Le applicazioni web, lato server, sono costruite mediante un approccio stratific
ato.
 Ciascuno stato interagisce unicamente con gli strati adiacenti e limita
 le dipendenze reciproche definendo i punti di contatto sotto forma di interfacc
e.
 Questo approccio enfatizza la modularità della soluzione ed il principio
 della separazione delle responsabilità.
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

Il Data Access Layer si occupa del trasferimento delle singole entità da
 e verso la sorgente dei dati: offre metodi per il caricamento, il salvataggio,
 la cancellazione e la modifica di singoli oggetti referenziati attraverso
 un identificatore univoco (ID) e può anche offrire metodi per cercare oggetti
 sulla base del loro contenuto e per riperire tutte le entità connesse tramite
 una certa relazione ad un'altra entità data.
 Spesso è costituito da un insieme di oggetti DAO (Data Access Object) che
 possono appoggiarsi ad un ORM (Object Relational Mapping) o implementare
 le proprie logiche direttamente.
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

Il Domain Layer rappresenta il modello logico dei dati cui deve essere applicata
 la logica di business dell'applicazione: questo costituisce un'astrazione
 dei concetti e delle relazioni tra essi esistenti all'interno del dominio
 applicativo, e si appoggia allo strato di accesso dati per reperire/rendere
 persistenti le informazioni che lo alimentano.
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

Il Service Layer definisce il contratto tra l'utente e l'applicazione: offre
 metodi che corrispondono alle azioni logiche che l'utente può svolgere
 con l'applicazione.
 Inoltre, coordina le attività e delega i vari compiti agli oggetti del
 dominio applicativo: il suo stato riflette la progressione dei compiti
 da svolgere, piuttosto che lo stato di ciascun compito.
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

Il Presentation Layer ha sostanzialmente due compiti principali: trasformare
 le richieste provenienti dall'utente in operazioni sullo strato di servizio
 e incapsulare i risultati all'interno delle risposte che dovranno essere
 visualizzate sul dispositivo dell'utente.
 Data la natura multi-user delle applicazioni web, questo strato può interagire
 con il meccanismo delle sessioni.
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

La sequenza degli eventi non è nota a priori: i comandi arrivano in successione
 nel tempo e il programma reagisce agli eventi esterni adottando un opportuno
 comportamento in base alla storia passata.
 Quindi, occorre 
\begin_inset Quotes eld
\end_inset

dare un senso
\begin_inset Quotes erd
\end_inset

 a questa sequenza interpretando ogni evento nell'ottica della funzione
 che il programma intende svolgere: bisogna, ad esempio, distinguere i dati
 inseriti dai comandi, verificare correttezza e congruenza dei dati, eseguire
 comandi ecc..
\begin_inset Newline newline
\end_inset

Per evitare che i programmi diventino rapidamente illeggibili, occorre separarli
 in un insieme di componenti ed uno degli approcci più adottati è quello
 detto Model-View-Controller.
\begin_inset Newline newline
\end_inset

La vista è una rappresentazione visuale del modello.
 Il controllore intercetta le richieste entranti, estrae i parametri, invoca
 lo strato di servizio e sceglie la vista da presentare, che verrà popolata
 con i dati ottenuti dal modello.
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Subsection*
MODELLO
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Un'applicazione è uno strumento informatico che consente ad un utente di
 elaborare informazioni: esse devono essere contenute e sono soggette ad
 un insieme di vincoli logici.
 Per gestire tali informazioni si utilizza un apposito oggetto che viene
 detto 
\begin_inset Quotes eld
\end_inset

modello
\begin_inset Quotes erd
\end_inset

.
 Esso non si occupa affatto dell'interfaccia ma solo dei dati che vengono
 incapsulati nei suoi attributi su cui l'applicazione opera.
 Può essere acceduto da uno strato di servizio.
 E' realizzato tramite un inseme di oggetti Java memorizzati all'interno
 della sessione o dell'applicazione, o resi persistenti in file o in una
 base dati.
\begin_inset Newline newline
\end_inset

Il modello deve essere il punto di partenza nello sviluppo di un progetto.
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Subsection*
VISTA
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Una vista è un oggetto specializzato nel mostrare quanto contenuto nel modello.
 La vista non modifica in alcun modo il modello e, a parità di modello,
 possono esistere viste diverse, ciascuna dedicata a mostrarne una parte
 o a presentare le informazioni in modo diverso.
 Le viste sono realizzate tramite 
\begin_inset Quotes eld
\end_inset

scheletri
\begin_inset Quotes erd
\end_inset

 HTML/XML/JSON
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Subsection*
CONTROLLORE
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Oggetto che mette in comunicazione le azioni eseguite sull'interfaccia offerta
 dalla vista con le operazioni offerte dal modello.
 Il controllore costituisce il nucleo dell'interazione ed è rappresentato
 da codice che identifica i parametri ricevuti, aggiorna il modello attraverso
 le interfacce di servizio e sceglie la vista opportuna
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

Per ogni tipo di richiesta viene definita una URL opportuna: qui viene mappato
 il controllore responsabile della sua gestione (spesso implementato come
 servlet) e per ogni vista viene preparata una opportuna implementazione.
 Per ogni URL supportata, occorre definire un controllore con i relativi
 metodi.
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Part*
SPRING FRAMEWORK
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Il cuore del framework Spring è basato su Inversion of Control, Dependency
 Injection e programmazione orientata agli oggetti: si fa largo utilizzo
 del concetto di POJO-oriented development, ovvero non obbliga ad organizzare
 le classi in una specifica gerarchia di ereditarietà, nè ad implementare
 specifiche interfacce.
 Tutte le applicazioni ad oggetti sono basate su un insieme di classi che
 interagiscono secondo una qualche logica, ciascun oggetto è responsabile
 di ottenere i riferimenti degli oggetti con cui deve interagire, detti
 dipendenze.
 Questo pattern porta alla realizzazione di applicazioni strettamente accoppiate
: se una classe dipende da una seconda non può essere compilata, testata
 e deployata in assenza della seconda, è ciò rende il sitema fragile e difficile
 da mantenere! Occorre rendere indipendenti le due classi, eliminando i
 riferimenti in compilazione ma facendo in modo di non perdere il legame
 in fase di esecuzione.
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Subsection*
INVERSION OF CONTROL
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Si elimina la dipendenza diretta nel codice sorgente introducendo un'interfaccia
 che ne astragga il comportamento.
 Essa separa due tipi di responsabilità: COSA deve essere fatto e QUANDO
 deve essere fatto; in generale, si realizza questo tipo di inversione passando
 da una modalità a chiamata diretta su un oggetto a propria scelta ad una
 chiamata indiretta su un oggetto fornito da altri.
 Questo sposta il problema su chi deve instanziare la prima classe, ossia
 occorre fornire un parametro opportuno al costruttore.
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Subsection*
DEPENDENCY INJECTION
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Pattern di programmazione che realizza l'accoppiamento tra gli oggetti in
 fase di esecuzione invece che in fase di compilazione: si affida ad un
 componente esterno la responsabilità di creare un grafo di dipendenze da
 oggetti: essi vengono tra loro collegati sulla base di un insieme di elementi
 di natura dichiarativa (nome, tipo, annotazioni), da una terza parte (framework
) appositamente delegata.
\begin_inset Newline newline
\end_inset

In questo modo, tutte le dipendenze vengono create e salvate in un contenitore
 e successivamente iniettate nel programma principale sotto forma di proprietà
 degli oggetti: approccio contrario alla normale creazione di applicazioni!
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

Ci sono diversi modi con cui i vari componenti possono essere legati tra
 loro in Spring, eventualmente mischiandoli tra loro:
\end_layout

\begin_layout Itemize
Configurazione esplicita tramite un file XML
\end_layout

\begin_layout Itemize
Configurazione esplicita tramite l'utilizzo di classi Java
\end_layout

\begin_layout Itemize
Scoperta implicita dei bean e autowiring automatico
\end_layout

\begin_layout Subsection*
ASPECT ORIENTED PROGRAMMING
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Paradigma di programmazione in grado di descrivere comportamenti trasversali
 all'applicazione, separandoli dal dominio applicativo.
 Si definisce cross-cutting concern una qualunque funzionalità che riguarda
 più punti di un'applicazione: esse possono essere modularizzate in speciali
 classi, chiamate aspect.
 Portano due benefici: la logica relativa ai comportamenti trasversali non
 è ripetuta e le classi a cui applicare gli aspeetti sono più pulite poichè
 contengono solo le loro funzionalità primarie.
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

Il lavoro compiuto da un aspect è detto advice, e Spring supporta 5 advice:
 before, after, after-returning, after-throwing, around (before+after).
 Da un punto di vista pratico, nella programmazione ad aspetti le classi
 base scritte dal programmatore sono modificate in fase di caricamento.
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Subsection*
CONTENITORE
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
In un'applicazione Spring, gli oggetti sono creati e legati tra loro da
 un container che crea oggetti, li collega e ne gestisce il ciclo di vita.
 Vi possono essere diverse implementazioni, categorizzate in due tipologie:
 BeanFactory (scenari semplici) e ApplicationContext (scenari di complessità
 arbitraria).
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

Il primo (XMLBeanFactory) è un semplice contenitore fornito da Spring, che
 crea ed istanzia i bean insieme a tutte le configurazioni di dipendenza.
 Quando un bean viene richiesto, il client ne ottiene un'istanza completamente
 funzionale.
 Utilizzato solitamente per applicazioni mobili o nei contesti in cui le
 risorse sono limitate.
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

Il secondo (ApplicationContext) ne è un'estensione che, alla gestione del
 ciclo di vita dei bean, aggiunge diversi supporti, tra cui una versione
 estesa del pattern 
\begin_inset Quotes eld
\end_inset

observer
\begin_inset Quotes erd
\end_inset

 con il supporto della tecnica publih/subscribe.
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Subsection*
BEAN
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Spring identifica come bean tutte le classi che sono etichettate come @Component.
 Se una classe è etichettata come @Configuration, tutti i suoi metodi etichettat
i con @Bean vengono invocati.
 In una tradizionale applicazione Java, il ciclo di vita degli oggetti è
 semplice: viene usata la keyword 
\begin_inset Quotes eld
\end_inset

new
\begin_inset Quotes erd
\end_inset

 per istanziare l'oggetto e lo rende pronto per essere utilizzato, per poi
 divenire candidato per la garbage collection.
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

Il ciclo di vita dei Bean è più complicato:
\end_layout

\begin_layout Itemize
Il contenitore carica le definizioni dei bean.
 Quando gli viene chiesto un bean specifico lo istanzia
\end_layout

\begin_layout Itemize
Il bean viene popolato con le proprietà dichiarate nelle definizioni.
 Se una proprietà ha un riferimento ad un altro bean, questo viene creato
 e inizializzato prima di procedere con la creazione del bean che lo referenzia
\end_layout

\begin_layout Itemize
Se il bean implementa determinate interfacce, vengono chiamati i metodi
 appropriati.
\end_layout

\begin_layout Itemize
Se viene indicato un BeanPostProcessor, il framework ne invoca il metodo
 di pre-inizializzazione
\end_layout

\begin_layout Itemize
Se l'oggetto creato implementa l'interfaccia InitializingBean, il framework
 invoca il metodo afterPropertiesSet()
\end_layout

\begin_layout Itemize
Se specificato tramite l'annotazione @Bean(initMethod="..."), viene invocato
 il metodo indicato
\end_layout

\begin_layout Itemize
Se viene indicato un BeanPostProcessor, il framework ne invoca il metodo
 di post-inizializzazione
\end_layout

\begin_layout Itemize
Al termine del suo ciclo di vita, se implementa DisposableBean viene invocato
 il metodo destroy().
 Se è stato specificato un distruttore, questo viene eseguito
\end_layout

\begin_layout Standard
All'atto della definizione, è possibile indicarne la visibilità con @Scope(...)
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Subsection*
AUTOWIRING
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
L'autowiring è un modo per lasciare a Spring il compito di risolvere automaticam
ente le dipendenze tra i bean.
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

Autowire per costruttore: la presenza dell'annotazione @Autowired su un
 costruttore con parametri abilita l'istanziazione del bean (per ciascun
 parametro il contenitore cerca un bean del tipo richiesto e lo inietta
 nel costruttore).
 Se sono presenti più bean il cui tipo corrisponde a un dato argomento del
 costruttore, viene generata un'eccezione: per evitare ambiguità si può
 segnalare che un dato bean non è un candidato primario per l'iniezione
 utilizzando primary=false.
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

Autowire per tipo: l'annotazione @Autowired può essere applicata anche a
 singoli campi di un oggetto o ai suoi metodi setter.
 In questo caso, il contenitore cerca, per ogni campo/metodo, un bean il
 cui tipo coincide con il tipo richiesto: se è un array o una collezione,
 esso inietta tutti i bean con il tipo degli elementi degli array o della
 collezione.
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

Autowire per nome: usando l'annotazione @Resource(name=
\begin_inset Quotes erd
\end_inset

...
\begin_inset Quotes erd
\end_inset

) è possibile indicare che deve essere iniettato uno specifico bean sulla
 base del nome con cui è noto al contenitore.
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Subsubsection*
APPLICATION.PROPERTIES
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Ogni progetto Spring Boot ha associato un file di configurazione application.prop
erties il cui caricamento è implicito.
 Si possono aggiungere righe nella forma <chiave>=<valore> che dipendono
 dai moduli aggiunti al progetto.
 I valori fissati all'interno del file delle proprietà possono essere assegnati
 a campi presenti all'interno della classe principale o in qualunque altra
 classe etichettata con l'annotazione @Component
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Subsection*
VISUALIZZAZIONE PAGINE HTML
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Una classe annotata con @Controller viene automaticamente istanziata in
 quanto @Component (Spring cerca tra i suoi metodi @RequestMapping per identific
are quali URL siano disponibili).
 Ogni volta che viene ricevuta una richiesta per il verbo HTTP e URL associati
 ad un dato metodo, questo viene invocato ed il suo valore di ritorno viene
 utilizzato per selezionare una vista opportuna che verrà restituita come
 risposta.
 La trasformazione di tale valore in una vista è affidata ad un apposito
 bean, il viewResolver e se tale valore è una stringa, il suo nome indica
 il nome della vista.
\begin_inset Newline newline
\end_inset

Il file selezionato viene elaborato ed inviato come risposta alla richiesta
 e il controllore può specificare, tra i propri parametri, un riferimento
 ad un oggetto di tipo Model (consiste sotanzialmente in una mappa chiave-valore
).
 Un controllore può ricevere informazioni in tre modi: tramite i segmenti
 di testo che formano la URL (annotare con @PathVariable), tramite i parametri
 posti nella queryString (parametri del metodo del controllore, usando annotazio
ne @RequestParam<paramName>) oppure tramite POST e PUT (passati sotto forma
 di oggetto Java a condizione che sia dotato di metodi get/set, e può venire
 indicato come parametro in ingresso al metodo del controllore e ci pensa
 Spring a istanziare).
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

In molte situazioni è necessario verificare che i dati rispettino un insieme
 di vincoli formali, e Spring offre un meccanismo generale: gli attributi
 dell'oggetto DTO possono essere etichettati con annotazioni tipo @NotNull
 @Min<val> @Valid.
 Quest'ultimo aggiunge un parametro BindingResult che verifica gli errori
 che possono essere visti tramite hasErrors().
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Subsection*
SPRING SERVICES
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Le funzionalità offerte dall'applicazione sono normalmente formulate sotto
 forma di API: i metodi di tale interfaccia costituiscono la logica mentre
 i data passati/restituiti descrivono le astrazioni del dominio applicativo.
 A partire dalla definizione di servizio, è possibile formulare un insieme
 di test e un'implementazione fittizia (mock) che permette di suddividere
 il lavoro tra gruppi di sviluppatori diversi.
\begin_inset Newline newline
\end_inset

Il meccanismo di inserimento delle dipendenze offre il substrato per implementar
e facilmente la logica applicativa: appositi oggetti etichettati con @Service
 offrono le funzionalità effettive del servizio che si intende erogare.
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

Il ViewModel è un oggetto che veicola i dati da mandare alla vista (JSON),
 tipicamente contiene i valori inseriti dall'utente nei form.
\begin_inset Newline newline
\end_inset

I DTO (Data Transfer Object) modella le informazioni che l'interfaccia del
 servizio offre e/o consuma: il controller si occupa di trasformare le informazi
oni ricevute in ingresso in uno o più DTO necessari per il servizio e si
 occupa inoltre di trasformare i dati restituiti da questo in un ViewModel
 adatto.
\begin_inset Newline newline
\end_inset

Le Entity modellano i dati così come vengono tenuti nel DB, permettendo
 di disaccoppiare lo strato di servizio da quello di persistenza e aggiungere
 informazioni necessarie alla indicizzazione e alle query.
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

Per accedere ai dati si può non coinvolgere il framework Spring (totale
 flessibilità, ma nessun servizio offerto dalla piattaforma!) oppure appoggiarsi
 alle funzionalità del framework (sforzo leggermente maggiore nel configurare
 l'ambiente ma ben ripagato!)
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Subsection*
REPOSITORY
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Nome usato nella terminologia Spring per definire una classe DAO, che offre
 metodi per eseguire operazioni di accesso ad una singola tabella della
 base dati sottostante, e si definisce come Repository<T, Id>.
 
\begin_inset Newline newline
\end_inset

T rappresenta la classe che descrive il dato mentre Id è il tipo di chiave
 primaria degli oggetti T (deve essere serializzabile e in T deve esserci
 un campo annotato con @Id ).
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Section*
JDBC
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Java Data Base Connectivity: permette l'accesso a database relazionali,
 con un basso livello di astrazione (il programmatore si deve occupare di
 quasi tutti i dettagli).
\begin_inset Newline newline
\end_inset

I driver JDBC rappresentano il punto di congiunzione tra le due librerie
 e il DBMS: esse vengono istanziate indirettamente attraverso la classe
 factory DriverManager.
 Il DB è rappresentato da una URL e per connettersi bisogna usare getConnection(
DbURL, User, Psw).
 Il formato è solitamente del tipo jdbc:subprotocol:source.
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

Per eseguire un'interrogazione, bisogna effettuare cinque passi fondamentali:
\end_layout

\begin_layout Enumerate
Registrazione del driver (una sola volta)
\end_layout

\begin_layout Enumerate
Connessione al database
\end_layout

\begin_layout Enumerate
Invio dell'interrogazione
\end_layout

\begin_layout Enumerate
Lettura dei risultati
\end_layout

\begin_layout Enumerate
Rilascio delle risorse
\end_layout

\begin_layout Standard
L'interfaccia per inviare i comandi sotto forma di stringhe è chiamata Statement
, che ha come metodi quelli di eseguire delle interrogazioni (executeQuery,
 executeUpdate) e rilasciare le risorse utilizzate (close()).
\begin_inset Newline newline
\end_inset

Come oggetto risultato si ha il ResultSet, che organizza i dati in forma
 tabulare (ad ogni riga corrisponde un record restituito, in modo tale da
 poter richiamare le righe ad una ad una, tramite un cursore).
 Si accede ai dati della riga puntata dal cursore tramite i metodi getXXXX(field
Name) o getXXXX(columnIndex).
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

E' possibile associare una classe ad ogni tabella presente nella base dati:
 i suoi attributi quind corrispondono alle colonne della tabella.
 Per ogni classe del dominio si definisce anche una classe DAO (Data Access
 Object) i cui metodi offrono le funzionalità necessarie a creare, reperire,
 modificare ed eliminare singole righe nella tabella (CRUD).
 Per default, eventuali cambiamenti vengono automaticamente confermati dopo
 l'esecuzione di ogni istruzione SQL e per disabilitare questo comportamento
 (per raggruppare più istruzioni in una transazione oppure gestire la concorrenz
a) si utilizza il metodo setAutoCommit(false).
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Section*
HIBERNATE E JPA
\begin_inset space ~
\end_inset


\end_layout

\end_body
\end_document
